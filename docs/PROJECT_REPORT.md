# Mini SQL Compiler for Query Validation
## Compiler Design Project Report

---

## 1. Project Overview

### 1.1 Introduction

This project implements a **Mini SQL Compiler** that validates SQL SELECT queries by simulating the core phases of compiler design. The compiler checks queries for lexical, syntactic, and semantic correctness without executing them on a real database.

### 1.2 Objectives

1. Implement a **Lexical Analyzer** to tokenize SQL queries
2. Develop a **Syntax Analyzer** using recursive descent parsing
3. Create a **Semantic Analyzer** with symbol table management
4. Design comprehensive **Error Handling** with meaningful messages
5. Generate **Parse Tree** as intermediate representation

### 1.3 Team Structure

| Member | Role | Deliverables |
|--------|------|--------------|
| Member 1 | Lexical Analysis | Token definitions, Tokenizer |
| Member 2 | Syntax Analysis | Grammar design, Parser |
| Member 3 | Semantic Analysis | Symbol table, Validation |
| Member 4 | Error Handling | Error module, Testing, Docs |

---

## 2. Compiler Phases

### 2.1 Lexical Analysis (Member 1)

**Theory:**
Lexical analysis is the first phase of compilation. It reads the source code character by character and groups them into **tokens** - the smallest meaningful units.

**Token Categories:**
| Category | Examples | Pattern |
|----------|----------|---------|
| Keywords | SELECT, FROM, WHERE | Reserved words |
| Identifiers | employee, name, age | [a-zA-Z_][a-zA-Z0-9_]* |
| Numbers | 25, 100.5 | [0-9]+(.[0-9]+)? |
| String Literals | 'John', 'Sales' | '...' |
| Operators | =, <, >, *, , | Single characters |

**Implementation:**
```cpp
class Lexer {
    std::string source;
    std::vector<Token> tokens;
    
    void scanToken();      // Main scanning logic
    void scanIdentifier(); // Handle keywords/identifiers
    void scanNumber();     // Handle numeric literals
    void scanString();     // Handle string literals
};
```

### 2.2 Syntax Analysis (Member 2)

**Theory:**
Syntax analysis verifies that the token sequence follows the grammatical rules of SQL. We use **Recursive Descent Parsing**, a top-down technique where each grammar rule has a corresponding function.

**SQL Grammar (BNF):**
```
<query>        ::= SELECT <column_list> FROM <table_name> [<where_clause>] ;
<column_list>  ::= * | <column_name> { , <column_name> }*
<column_name>  ::= IDENTIFIER
<table_name>   ::= IDENTIFIER
<where_clause> ::= WHERE <condition>
<condition>    ::= <column_name> <rel_op> <value>
<rel_op>       ::= = | < | >
<value>        ::= IDENTIFIER | NUMBER | STRING_LITERAL
```

**Parse Tree Construction:**
The parser builds a hierarchical tree structure representing the query's syntactic structure.

### 2.3 Semantic Analysis (Member 3)

**Theory:**
Semantic analysis checks the **meaning** of the program - aspects that cannot be expressed in a context-free grammar.

**Validations Performed:**
1. **Table Existence:** Does the referenced table exist?
2. **Column Existence:** Do columns belong to the specified table?
3. **Type Compatibility:** Are comparisons type-safe?

**Symbol Table:**
```cpp
struct TableInfo {
    std::string name;
    std::vector<ColumnInfo> columns;
};

class SymbolTable {
    std::unordered_map<std::string, TableInfo> tables;
    
    bool tableExists(const std::string& name);
    bool columnExists(const std::string& table, const std::string& column);
};
```

### 2.4 Error Handling (Member 4)

**Error Types:**
| Type | Phase | Example |
|------|-------|---------|
| Lexical Error | Lexer | Invalid character '@' |
| Syntax Error | Parser | Missing 'FROM' keyword |
| Semantic Error | Semantic | Table 'customers' doesn't exist |

**Error Message Format:**
```
[Error Type] at Line X, Column Y: Description
  1 | SELECT @ FROM users;
    |        ^~~~
```

---

## 3. Implementation Details

### 3.1 Project Structure

```
compiler/
├── include/           # Header files
│   ├── common.h       # Shared types
│   ├── lexer.h
│   ├── parser.h
│   ├── semantic.h
│   ├── symbol_table.h
│   └── error_handler.h
├── src/               # Source files
│   ├── main.cpp
│   ├── lexer.cpp
│   ├── parser.cpp
│   ├── semantic.cpp
│   ├── symbol_table.cpp
│   └── error_handler.cpp
├── tests/             # Test queries
├── docs/              # Documentation
└── Makefile
```

### 3.2 Data Flow

```
                     ┌─────────────────────────────────────────┐
                     │             SQL Query                   │
                     │   "SELECT * FROM employees;"            │
                     └─────────────────┬───────────────────────┘
                                       │
                                       ▼
┌──────────────────────────────────────────────────────────────────────┐
│  PHASE 1: LEXICAL ANALYSIS                                          │
│  ─────────────────────────                                          │
│  Input: Character stream                                            │
│  Output: Token stream                                                │
│  [KEYWORD_SELECT, OP_STAR, KEYWORD_FROM, IDENTIFIER, OP_SEMICOLON]  │
└────────────────────────────────────┬─────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────┐
│  PHASE 2: SYNTAX ANALYSIS                                           │
│  ────────────────────────                                           │
│  Input: Token stream                                                 │
│  Output: Parse Tree                                                  │
│  QUERY → SELECT_CLAUSE → COLUMN_LIST → FROM_CLAUSE → TABLE_NAME     │
└────────────────────────────────────┬─────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────┐
│  PHASE 3: SEMANTIC ANALYSIS                                         │
│  ──────────────────────────                                         │
│  Input: Parse Tree + Symbol Table                                    │
│  Output: Validation Result                                           │
│  Checks: Table exists? Columns valid?                                │
└────────────────────────────────────┬─────────────────────────────────┘
                                     │
                                     ▼
┌──────────────────────────────────────────────────────────────────────┐
│  PHASE 4: OUTPUT                                                     │
│  ──────────────                                                     │
│  Compilation Summary with errors (if any)                            │
│  ╔═══════════════════════════════════════╗                          │
│  ║   QUERY VALIDATION: SUCCESSFUL        ║                          │
│  ╚═══════════════════════════════════════╝                          │
└──────────────────────────────────────────────────────────────────────┘
```

---

## 4. Sample Tables (Schema)

| Table | Columns |
|-------|---------|
| employees | id (INT), name (VARCHAR), age (INT), salary (FLOAT), department (VARCHAR) |
| departments | id (INT), name (VARCHAR), budget (FLOAT) |
| users | id (INT), username (VARCHAR), email (VARCHAR), age (INT), status (VARCHAR) |
| products | id (INT), name (VARCHAR), price (FLOAT), quantity (INT) |

---

## 5. Sample Queries and Outputs

### 5.1 Valid Query Example

**Input:**
```sql
SELECT name, age FROM employees WHERE age > 25;
```

**Token Stream:**
| Token Type | Value |
|------------|-------|
| KEYWORD_SELECT | SELECT |
| IDENTIFIER | name |
| OP_COMMA | , |
| IDENTIFIER | age |
| KEYWORD_FROM | FROM |
| IDENTIFIER | employees |
| KEYWORD_WHERE | WHERE |
| IDENTIFIER | age |
| OP_GREATER_THAN | > |
| NUMBER | 25 |
| OP_SEMICOLON | ; |

**Parse Tree:**
```
QUERY
├── SELECT_CLAUSE: "SELECT"
│   └── COLUMN_LIST
│       ├── COLUMN: "name"
│       └── COLUMN: "age"
├── FROM_CLAUSE: "FROM"
│   └── TABLE_NAME: "employees"
└── WHERE_CLAUSE: "WHERE"
    └── CONDITION
        ├── COLUMN: "age"
        ├── OPERATOR: ">"
        └── VALUE: "25"
```

**Result:** Query is VALID ✓

### 5.2 Invalid Query Example (Syntax Error)

**Input:**
```sql
SELECT * employees;
```

**Error Output:**
```
Syntax Error at Line 1, Column 10: Expected 'FROM' keyword (found 'employees')
  1 | SELECT * employees;
    |          ^~~~
```

---

## 6. Future Scope

1. **AND/OR Support:** Extend WHERE clause to support compound conditions
2. **JOIN Operations:** Add support for table joins
3. **Aggregate Functions:** Implement COUNT, SUM, AVG, etc.
4. **Subqueries:** Support nested SELECT statements
5. **CREATE/INSERT/UPDATE:** Extend to full DML support
6. **GUI Interface:** Web-based query validation interface

---

## 7. Conclusion

This project successfully demonstrates the implementation of core compiler phases for SQL query validation. The modular design allows easy extension and maintenance. The project provides hands-on experience with:

- Lexical analysis and tokenization
- Grammar design and recursive descent parsing
- Symbol table management and semantic validation
- Compiler error handling and reporting

The Mini SQL Compiler serves as an educational tool for understanding how real database engines validate queries before execution.

---

## 8. References

1. Aho, A.V., Sethi, R., & Ullman, J.D. (2006). *Compilers: Principles, Techniques, and Tools* (2nd ed.)
2. Cooper, K.D., & Torczon, L. (2011). *Engineering a Compiler* (2nd ed.)
3. SQL Language Reference - Oracle Documentation
4. C++ ISO Standard (C++17)
